"use strict";const t=[Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array];class s{static from(e){if(!(e instanceof ArrayBuffer))throw new Error("Data must be an instance of ArrayBuffer.");const[i,n]=new Uint8Array(e,0,2);if(219!==i)throw new Error("Data does not appear to be in a KDBush format.");const o=n>>4;if(1!==o)throw new Error(`Got v${o} data when expected v1.`);const r=t[15&n];if(!r)throw new Error("Unrecognized array type.");const[h]=new Uint16Array(e,2,1),[a]=new Uint32Array(e,4,1);return new s(a,h,r,e)}constructor(s,e=64,i=Float64Array,n){if(isNaN(s)||s<0)throw new Error(`Unpexpected numItems value: ${s}.`);this.numItems=+s,this.nodeSize=Math.min(Math.max(+e,2),65535),this.ArrayType=i,this.IndexArrayType=s<65536?Uint16Array:Uint32Array;const o=t.indexOf(this.ArrayType),r=2*s*this.ArrayType.BYTES_PER_ELEMENT,h=s*this.IndexArrayType.BYTES_PER_ELEMENT,a=(8-h%8)%8;if(o<0)throw new Error(`Unexpected typed array class: ${i}.`);n&&n instanceof ArrayBuffer?(this.data=n,this.ids=new this.IndexArrayType(this.data,8,s),this.coords=new this.ArrayType(this.data,8+h+a,2*s),this._pos=2*s,this._finished=!0):(this.data=new ArrayBuffer(8+r+h+a),this.ids=new this.IndexArrayType(this.data,8,s),this.coords=new this.ArrayType(this.data,8+h+a,2*s),this._pos=0,this._finished=!1,new Uint8Array(this.data,0,2).set([219,16+o]),new Uint16Array(this.data,2,1)[0]=e,new Uint32Array(this.data,4,1)[0]=s)}add(t,s){const e=this._pos>>1;return this.ids[e]=e,this.coords[this._pos++]=t,this.coords[this._pos++]=s,e}finish(){const t=this._pos>>1;if(t!==this.numItems)throw new Error(`Added ${t} items when expected ${this.numItems}.`);return e(this.ids,this.coords,this.nodeSize,0,this.numItems-1,0),this._finished=!0,this}range(t,s,e,i){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");const{ids:n,coords:o,nodeSize:r}=this,h=[0,n.length-1,0],a=[];for(;h.length;){const c=h.pop()||0,p=h.pop()||0,u=h.pop()||0;if(p-u<=r){for(let r=u;r<=p;r++){const h=o[2*r],c=o[2*r+1];h>=t&&h<=e&&c>=s&&c<=i&&a.push(n[r])}continue}const d=u+p>>1,l=o[2*d],f=o[2*d+1];l>=t&&l<=e&&f>=s&&f<=i&&a.push(n[d]),(0===c?t<=l:s<=f)&&(h.push(u),h.push(d-1),h.push(1-c)),(0===c?e>=l:i>=f)&&(h.push(d+1),h.push(p),h.push(1-c))}return a}within(t,s,e){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");const{ids:i,coords:n,nodeSize:o}=this,h=[0,i.length-1,0],a=[],c=e*e;for(;h.length;){const p=h.pop()||0,u=h.pop()||0,d=h.pop()||0;if(u-d<=o){for(let e=d;e<=u;e++)r(n[2*e],n[2*e+1],t,s)<=c&&a.push(i[e]);continue}const l=d+u>>1,f=n[2*l],m=n[2*l+1];r(f,m,t,s)<=c&&a.push(i[l]),(0===p?t-e<=f:s-e<=m)&&(h.push(d),h.push(l-1),h.push(1-p)),(0===p?t+e>=f:s+e>=m)&&(h.push(l+1),h.push(u),h.push(1-p))}return a}}function e(t,s,n,o,r,h){if(r-o<=n)return;const a=o+r>>1;i(t,s,a,o,r,h),e(t,s,n,o,a-1,1-h),e(t,s,n,a+1,r,1-h)}function i(t,s,e,o,r,h){for(;r>o;){if(r-o>600){const n=r-o+1,a=e-o+1,c=Math.log(n),p=.5*Math.exp(2*c/3),u=.5*Math.sqrt(c*p*(n-p)/n)*(a-n/2<0?-1:1);i(t,s,e,Math.max(o,Math.floor(e-a*p/n+u)),Math.min(r,Math.floor(e+(n-a)*p/n+u)),h)}const a=s[2*e+h];let c=o,p=r;for(n(t,s,o,e),s[2*r+h]>a&&n(t,s,o,r);c<p;){for(n(t,s,c,p),c++,p--;s[2*c+h]<a;)c++;for(;s[2*p+h]>a;)p--}s[2*o+h]===a?n(t,s,o,p):(p++,n(t,s,p,r)),p<=e&&(o=p+1),e<=p&&(r=p-1)}}function n(t,s,e,i){o(t,e,i),o(s,2*e,2*i),o(s,2*e+1,2*i+1)}function o(t,s,e){const i=t[s];t[s]=t[e],t[e]=i}function r(t,s,e,i){const n=t-e,o=s-i;return n*n+o*o}const h={minZoom:0,maxZoom:16,minPoints:2,radius:40,extent:512,nodeSize:64,log:!1,generateId:!1,reduce:null,map:t=>t},a=Math.fround||(c=new Float32Array(1),t=>(c[0]=+t,c[0]));var c;const p=3,u=5,d=6;function l(t,s,e){return{type:"Feature",id:t[s+p],properties:f(t,s,e),geometry:{type:"Point",coordinates:[(i=t[s],360*(i-.5)),y(t[s+1])]}};var i}function f(t,s,e){const i=t[s+u],n=i>=1e4?`${Math.round(i/1e3)}k`:i>=1e3?Math.round(i/100)/10+"k":i,o=t[s+d],r=-1===o?{}:Object.assign({},e[o]);return Object.assign(r,{cluster:!0,cluster_id:t[s+p],point_count:i,point_count_abbreviated:n})}function m(t){return t/360+.5}function g(t){const s=Math.sin(t*Math.PI/180),e=.5-.25*Math.log((1+s)/(1-s))/Math.PI;return e<0?0:e>1?1:e}function y(t){const s=(180-360*t)*Math.PI/180;return 360*Math.atan(Math.exp(s))/Math.PI-90}module.exports=class{constructor(t){this.options=Object.assign(Object.create(h),t),this.trees=new Array(this.options.maxZoom+1),this.stride=this.options.reduce?7:6,this.clusterProps=[]}load(t){const{log:s,minZoom:e,maxZoom:i}=this.options;s&&console.time("total time");const n=`prepare ${t.length} points`;s&&console.time(n),this.points=t;const o=[];for(let s=0;s<t.length;s++){const e=t[s];if(!e.geometry)continue;const[i,n]=e.geometry.coordinates,r=a(m(i)),h=a(g(n));o.push(r,h,1/0,s,-1,1),this.options.reduce&&o.push(0)}let r=this.trees[i+1]=this._createTree(o);s&&console.timeEnd(n);for(let t=i;t>=e;t--){const e=+Date.now();r=this.trees[t]=this._createTree(this._cluster(r,t)),s&&console.log("z%d: %d clusters in %dms",t,r.numItems,+Date.now()-e)}return s&&console.timeEnd("total time"),this}getClusters(t,s){let e=((t[0]+180)%360+360)%360-180;const i=Math.max(-90,Math.min(90,t[1]));let n=180===t[2]?180:((t[2]+180)%360+360)%360-180;const o=Math.max(-90,Math.min(90,t[3]));if(t[2]-t[0]>=360)e=-180,n=180;else if(e>n){const t=this.getClusters([e,i,180,o],s),r=this.getClusters([-180,i,n,o],s);return t.concat(r)}const r=this.trees[this._limitZoom(s)],h=r.range(m(e),g(o),m(n),g(i)),a=r.data,c=[];for(const t of h){const s=this.stride*t;c.push(a[s+u]>1?l(a,s,this.clusterProps):this.points[a[s+p]])}return c}getChildren(t){const s=this._getOriginId(t),e=this._getOriginZoom(t),i="No cluster with the specified id.",n=this.trees[e];if(!n)throw new Error(i);const o=n.data;if(s*this.stride>=o.length)throw new Error(i);const r=this.options.radius/(this.options.extent*Math.pow(2,e-1)),h=o[s*this.stride],a=o[s*this.stride+1],c=n.within(h,a,r),d=[];for(const s of c){const e=s*this.stride;o[e+4]===t&&d.push(o[e+u]>1?l(o,e,this.clusterProps):this.points[o[e+p]])}if(0===d.length)throw new Error(i);return d}getLeaves(t,s,e){s=s||10,e=e||0;const i=[];return this._appendLeaves(i,t,s,e,0),i}getTile(t,s,e){const i=this.trees[this._limitZoom(t)],n=Math.pow(2,t),{extent:o,radius:r}=this.options,h=r/o,a=(e-h)/n,c=(e+1+h)/n,p={features:[]};return this._addTileFeatures(i.range((s-h)/n,a,(s+1+h)/n,c),i.data,s,e,n,p),0===s&&this._addTileFeatures(i.range(1-h/n,a,1,c),i.data,n,e,n,p),s===n-1&&this._addTileFeatures(i.range(0,a,h/n,c),i.data,-1,e,n,p),p.features.length?p:null}getClusterExpansionZoom(t){let s=this._getOriginZoom(t)-1;for(;s<=this.options.maxZoom;){const e=this.getChildren(t);if(s++,1!==e.length)break;t=e[0].properties.cluster_id}return s}_appendLeaves(t,s,e,i,n){const o=this.getChildren(s);for(const s of o){const o=s.properties;if(o&&o.cluster?n+o.point_count<=i?n+=o.point_count:n=this._appendLeaves(t,o.cluster_id,e,i,n):n<i?n++:t.push(s),t.length===e)break}return n}_createTree(t){const e=new s(t.length/this.stride|0,this.options.nodeSize,Float32Array);for(let s=0;s<t.length;s+=this.stride)e.add(t[s],t[s+1]);return e.finish(),e.data=t,e}_addTileFeatures(t,s,e,i,n,o){for(const r of t){const t=r*this.stride,h=s[t+u]>1;let a,c,d;if(h)a=f(s,t,this.clusterProps),c=s[t],d=s[t+1];else{const e=this.points[s[t+p]];a=e.properties;const[i,n]=e.geometry.coordinates;c=m(i),d=g(n)}const l={type:1,geometry:[[Math.round(this.options.extent*(c*n-e)),Math.round(this.options.extent*(d*n-i))]],tags:a};let y;y=h||this.options.generateId?s[t+p]:this.points[s[t+p]].id,void 0!==y&&(l.id=y),o.features.push(l)}}_limitZoom(t){return Math.max(this.options.minZoom,Math.min(Math.floor(+t),this.options.maxZoom+1))}_cluster(t,s){const{radius:e,extent:i,reduce:n,minPoints:o}=this.options,r=e/(i*Math.pow(2,s)),h=t.data,a=[],c=this.stride;for(let e=0;e<h.length;e+=c){if(h[e+2]<=s)continue;h[e+2]=s;const i=h[e],p=h[e+1],d=t.within(h[e],h[e+1],r),l=h[e+u];let f=l;for(const t of d){const e=t*c;h[e+2]>s&&(f+=h[e+u])}if(f>l&&f>=o){let t,o=i*l,r=p*l,m=-1;const g=((e/c|0)<<5)+(s+1)+this.points.length;for(const i of d){const a=i*c;if(h[a+2]<=s)continue;h[a+2]=s;const p=h[a+u];o+=h[a]*p,r+=h[a+1]*p,h[a+4]=g,n&&(t||(t=this._map(h,e,!0),m=this.clusterProps.length,this.clusterProps.push(t)),n(t,this._map(h,a)))}h[e+4]=g,a.push(o/f,r/f,1/0,g,-1,f),n&&a.push(m)}else{for(let t=0;t<c;t++)a.push(h[e+t]);if(f>1)for(const t of d){const e=t*c;if(!(h[e+2]<=s)){h[e+2]=s;for(let t=0;t<c;t++)a.push(h[e+t])}}}}return a}_getOriginId(t){return t-this.points.length>>5}_getOriginZoom(t){return(t-this.points.length)%32}_map(t,s,e){if(t[s+u]>1){const i=this.clusterProps[t[s+d]];return e?Object.assign({},i):i}const i=this.points[t[s+p]].properties,n=this.options.map(i);return e&&n===i?Object.assign({},n):n}};
